satisfying :: Prop -> [Valuation] -> [Valuation]
satisfying p = filter $ flip eval p . (Map.!)

union :: Valuation -> Valuation -> Maybe Valuation
union f g = if all ((\x ->(x `Map.notMember` f) || f Map.! x == g Map.! x ) . fst) (Map.toList g)
        then Just $ Map.union f g
        else Nothing

nonContradicting :: [Valuation] -> Maybe Valuation
nonContradicting = foldl (\ acc m -> acc >>= union m) (Just Map.empty)

--bruteIsTheorem :: Conjecture -> Bool
bruteIsTheorem :: Conjecture -> Bool
bruteIsTheorem ([] `Proves` q) = all (flip eval q . (Map.!)) $ allValuations q
bruteIsTheorem (ps `Proves` q) = all
  (flip eval q . (Map.!) . getFromJust) $
  filter isJust . map nonContradicting $ cartesian goodVals
    where   goodVals =  map (\p -> satisfying p (allValuations p)) ps -- Premisses -> Good Valuations
            isJust Nothing = False
            isJust _ = True
            getFromJust (Just x) = x

solve, solve' :: String -> Bool
solve = bruteIsTheorem . runParser conjectureParser 
solve' = easyBruteIsTheorem . runParser conjectureParser 


 Axiom -> " from Axioms\n"
        (AndL p) -> f "L ∧" ++ show p 
        (AndR p q) -> f "R ∧" ++ show p ++ show q
        (OrL p q)  -> f "L ∨" ++ show p ++ show q
        (OrR p )  -> f "R ∨" ++ show p
        (ImpL p q) -> f "L →" ++ show p ++ show q
        (ImpR p ) -> f "R →" ++ show p
        (NotL p ) -> f "L ¬" ++ show p
        (NotR p ) -> f "R ¬" ++ show p
        where f xs = " applying " ++ xs ++ " rule\n" 


show p = concat (zipWith (++) (map ((++".\t") . show) [1..]) (showProof p))





--- ∨ ¬  ∧ → ↔ ⊥

instance Show Rule where
    show r = concat (showRule r)

------- Proof Visaluation
showRule :: Rule -> [String]
showRule r =  case r of
    Axiom -> [" from Axioms\n"]
    AndL p -> f "L ∧" : showProof p
    (AndR p q) -> f "R ∧" : g (showProof p ++ showProof q)
    (OrL p q)  -> f "L ∨" : g (showProof p ++ showProof q)
    (OrR p )  -> f "R ∨" : showProof p
    (ImpL p q) -> f "L →" : g (showProof p ++ showProof q)
    (ImpR p ) -> f "R →" : showProof p
    (NotL p ) -> f "L ¬" : showProof p
    (NotR p ) -> f "R ¬" : showProof p
    (EqvR p q) -> f "R ↔" : g (showProof p ++ showProof q)
    where   f xs = " applying " ++ xs ++ " rule\n"
            g = map ('\t':)

showProof :: Proof -> [String]
showProof (Proof conj r) = (show conj ++ "\t\t" ++  head rs) : tail rs
    where   rs = showRule r
